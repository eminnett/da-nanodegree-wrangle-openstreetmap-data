# OpenStreetMap Data Wrangling with MongoDB
## Data Wrangling Project
#### Data Analyst Nanodegree (Udacity)
Project submission by Edward Minnett (ed@methodic.io).

August 9th 2016. (Revision 2)

----------

## Overview

This project seeks to apply data munging techniques to first analyse and clean Open Street Map data for a single city and then perform an exploratory analysis of the data after importing it into a MongoDB collection.

For the last couple of years I have lived in a small village south of Oxford so I chose to explore the Open Street Map data for Oxford England in attempt to learns something new not only about data munging and data analysis but also about Oxford itself. Having visited the city on quite a few occasions, I am confident that there is a lot of interesting information to be discovered through this analysis.

The data for this project was acquired from Map Zen. The compressed Oxford, England OSM XML data set can be downloaded by following this [link](https://s3.amazonaws.com/metro-extracts.mapzen.com/oxford_england.osm.bz2). The OSM file is 5.0 MB compressed and 66.2 MB uncompressed.

**NB**: *This report is a re-worded, more concise version of the complete data analysis. For more detail, please see this report in the accompanying IPython Notebook.*

## Problems encountered in the map

As you would expect from any crowd-sourced data, there is plenty of evidence of inconsistent naming conventions as well as evidence of human error when the data was entered. The three main areas of inconsistency are as follows:

- The names used to describe individual records within the data.
- Mistakes and abbreviations in street names.
- Missing 'cuisines' for nodes that describe places to eat.

This is what I found when digging deeper into these inconsistencies and attempting to fix them.

### Tag key name problems

The Tag Key problems are broken down into 8 categories but a few of these indicates 'no problem' or the problem is dealt with in a trivial fashion. For example, a single colon simply indicates a parent-child relationship within the taxonomy and uppercase characters can be easily dealt with by making sure the code that processes the Tag Key names uses the lowercase version of all names. There are, however, three categories that require further investigation.

The three categories with the number of affected tags.
- "problemchars": 5 (Tags Key names that contain characters that are not supported within  MongoDB keys),
- "multiple_colons": 608 (Tags Key names that contain more than one colon suggesting a deeper hierarchical relationship than simply parent-child.)
- "other": 1 (Anything that does not fall into any of the other 7 categories.)

Let's start by taking a look at the 'problemchars' and see how they could be fixed.

The 5 offending names:
- 'leaving for now'
- 'fee:amount:box_van&minibus'
- 'note:0.1'
- 'note:0.2'
- 'note 2'

These 'problems' are in no way a disaster and can be easily fixed by applying the following replacements:

- Replace ' ' with '\_'
- Replace '&' with '\_and\_'
- Replace '.' with '\_'

The key names that fall under 'multiple_colons' can be handled by adding additional nesting within the JSON data generated by the data munging process. Given that we could, in theory at least, have any number of colons in the string name, this particular problem could be solved very nicely using recursion.


The one remaining Tag Key name that fell under the 'other' category is 'name:sr-Latn'. Even though the inclusing of a hyphen meant this name was 'unhandled', the hyphen is a valid character in a MongoDB key and is fine as it is.

### Street name problems

An audit of the street names in the data set found 73 unique street name types ('Avenue', 'Street', 'Road'). This may seem like a problem in itself if you are used to American street names, but in England, street names ending in 'Close', 'Hill', 'Way', or 'Gardens' are not that uncommon. That said, there are genuine problems with the street names as we will find out next.

The first 10 of these 73 results.
- `'1': {'Avenue 1'}`
- `'2': {'Avenue 2'}`
- `'3': {'Avenue 3'}`
- `'4': {'Avenue 4'}`
- `"Aldate's": {"St Aldate's"}`
- `'Ave': {'Waverly Ave'}`
- `'Barr': {'Upper Barr'}`
- `'Bridge': {'Folly Bridge'}`
- `'Broadway': {'The Broadway'}`
- `'Buildings': {'Manor Buildings'}`
- ⋮

The large majority of the street names are valid, but there are a few cases of abbreviated street names such as 'Ave', 'Rd' and 'St'. There are also several cases of punctuations mistakes such as 'Way?' and 'Way,'. There are cases of both lowercase 'road' and 'way'. There is a typo where 'Reliuance Way' should be 'Reliance Way'. The oddest problems are the cases of 'Avenue 1' through 'Avenue 4'. In Kennington, just outside of Oxford, the main street is called 'The Avenue'. I believe these street names may be mistakes or parsing issues. They don't match any obvious street names and as a result will be treated as anomalies and removed from the data.

### Cuisine problems

Oxford is most famous for its colleges and museums, but it doesn't take long when walking around the city to notice the abundance and variety of places to eat. For this analysis, I considered nodes that contain a 'cuisine' tag or have an 'amenity' tag that matches any of 'restaurant', 'cafe', 'pub', 'bar', 'fast_food', or 'delicatessen' to be 'food nodes'. An audit of the food nodes found the following:

- Number of food nodes: 523
- Number of food nodes with a cuisine and amenity: 213
- Number of food nodes without a cuisine: 303
- Number of food nodes without an amenity: 7

We now know that there are more food nodes that are problematic than aren't (213 out of 523 have both a 'cuisine' and food 'amenity'), but this information alone isn't enough to understand what the problems are or how they may be fixed.

This analysis shows that there are definite problems with the cuisine classifications of food nodes within the data. Of the 523 nodes analysed, 303 have amenity types but no cuisine type and 7 have a cuisine type but no amenity type. The 7 nodes that have a cuisine but are missing an amenity can be explained as follows and don't need further analysis: four are shops and don't require an amenity and two are marked as disused one of which is missing. Only 'The Oriental Condor' looks like it should have an amenity type but does not. A quick search on Google suggests that 'The Oriental Condor' is in fact closed.

The 303 nodes that have food related amenities but lack a cuisine are broken down by amenity as follows:

- pub: 152
- cafe: 73
- restaurant: 31
- fast_food: 26
- bar: 21

I believe that the disproportionate representation of pubs within this data could potentially be explained by the pubs not serving food and as a result not needing a cuisine type although I find it hard to believe that Oxford has 153 that don't serve food. What may be more likely is that the creators of this data assumed that a node marked as a 'pub' serves 'pub food' and as a result does not need a 'cuisine'.

An analysis of the cuisines for each of the remaining 213 nodes broken down by amenity does not show a consistent pattern. A winner take all strategy (majority cuisine by amenity) to fix the 303 problem nodes would mean assigning 'indian' to all 'restaurants' and 'chinese' to all 'fast_food' nodes. This hardly seems appropriate.

A more sophisticated strategy would be to do a similarity analysis between node names and see if appropriate cuisines could be inferred from the node names. An initial attempt at fixing the 303 problem nodes this way also proved inappropriate. A sample application of this approach provided the following results:

```
Subject name: The Tree | Subject amenity: pub

Score: 0.538 | Name: The Gardeners Arms    | Cuisine: vegetarian
Score: 0.526 | Name: White Horse           | Cuisine: Fish and Chips and other pub favourites
Score: 0.500 | Name: The White Rabbit      | Cuisine: pizza
Score: 0.500 | Name: The Chequers          | Cuisine: burger
Score: 0.462 | Name: The Head of the River | Cuisine: burger
```

This suggests 'The Tree' pub is most similar to 'The Gardeners Arms' pub. This is a clever result in terms of string similarity, but 'The Gardeners Arms' serves vegetarian food and a little bit of research shows that the pub at The Tree Hotel serves standard pub fair (curry, steak etc.). This illustrates why trying to infer the cuisine through a simple string similarity analysis on the node names will likely result in badly assigned cuisine types. For this reason, I decided not to attempt to fix the cuisine problems deciding that adding bad information to the data is worse than accepting that some information is missing.

If fixing these problems was imperative, I would attempt to train a supervised learning algorithm to try and harness more information than just the names in attempt to more accurately label the missing cuisine types. If I were to apply this strategy, I would look for more data than just the 213 nodes from the Oxford data set as it would be unlikely that out of 516 nodes, 213 labeled data would be able to generalise over the remaining 303.

## Load the Data

After implementing data munging techniques and pre-processing the XML meant loading the data into MongoDB was reasonably straightforward and could be done repeatedly, in an idempotent fashion, without encountering additional problems. Loading the data resulted in:

- Number of records in the oxford_england MongoDB collection: `321322`
- A sample record from the oxford_england MongoDB collection: `{u'created': {u'changeset': u'10706805', u'version': u'4', u'uid': u'27408', u'timestamp': u'2012-02-16T23:08:31Z', u'user': u'Andrew Chadwick'}, u'pos': [51.6994959, -1.2645627], u'visible': None, u'_id': ObjectId('57963746d0958625140ac407'), u'type': u'node', u'id': u'194502'}`


## Overview of the data

The data for this project was acquired from Map Zen. The compressed Oxford, England OSM XML data set can be downloaded by following this [link](https://s3.amazonaws.com/metro-extracts.mapzen.com/oxford_england.osm.bz2). The OSM file is 5.0 MB compressed. The uncompressed files are as follows:

- **oxford_england.osm**: 66.21 MB in size.
- **oxford_england.osm.json**: 98.97 MB in size.

A brief overview analysis of the MongoDB data yielded the following statistics (the code used to find these statistics can be found in the accompanying IPython Notebook):

- Number of records: 321322
- Number of 'node' records: 274664
- Number of 'way' records: 46600
- Number of unique 'users': 567
- Number of unique 'amenity' values: 127
- Number of unique 'cuisine' values: 57
- Number of 'university' and 'college' records: 119

## Other ideas about the datasets

Oxford is a very interesting city not simply because of the history and prestige of Oxford University, but also because of its density and diversity of amenities woven within a fabric of well integrated networks of pedestrian, bicycle, and public transport routes. It would be very interesting to explore the relationships between these amenities and the various networks that allow people to move around the city.

The outcome of this analysis could be very helpful in planning activities and events within the city as well as providing information about which parts of the city are likely to be busiest during the tourist season.

That said, the OSM data for Oxford may not make such an analysis very easy to undertake. For example, data about the bus and rail networks are encoded using the NAPTAN schema ([NAPTAN stands for National Public Transport Access Nodes](https://www.gov.uk/government/publications/national-public-transport-access-node-schema)) but this information does not always contain information about street names. For example, theses two nodes can be found within the data (irrelevant details have been removed for brevity):

A bus stop node without street information.
```
{  
   'direction': 'W',
   'name': 'Herschel Crescent',
   'journeys': '6',
   ⋮
   'naptan': {  
      'Bearing':'W'
   },
   'source': 'photograph',
   'bus_routes': '16A',
   ⋮
   'type': 'node',
   ⋮
   'highway': 'bus_stop'
}
```
A bus stop node with street information.
```
{  
   'direction': 'W',
   'name': 'Long Lane',
   'journeys': '6',
   ⋮
   'naptan': {  
      'Bearing': 'W',
      'Indicator': 'Opp Sheldon Way',
      'BusStopType': 'CUS',
      'CommonName': 'Long Lane',
      'PlusbusZoneRef': 'OXFD',
      'Street': 'Long Lane',
      'Landmark': 'Sheldon Way',
      'AtcoCode': '340000958OPP',
      'NaptanCode': 'oxfatjdj'
   },
   'source': 'naptan_import;photograph',
   'bus_routes': '16A',
   ⋮
   'type': 'node',
   ⋮
   'highway': 'bus_stop'
}
```
I have started the process of doing a deeper analysis of the data. Even the code isn't strictly necessary to communicate the results, the queries were complicated enough that including some of the code helps validate the findings.

### The top 10 most common amenities

```python
>>> collection.aggregate([
            {"$match": {"amenity": {"$exists": 1}}},
            {"$group": {"_id": "$amenity", "count": {"$sum": 1}}},
            {"$sort": {"count": -1}},
            {"$limit": 10}
        ])

>>> {u'count': 741, u'_id': u'parking'}
    {u'count': 521, u'_id': u'bicycle_parking'}
    {u'count': 332, u'_id': u'post_box'}
    {u'count': 187, u'_id': u'bench'}
    {u'count': 164, u'_id': u'pub'}
    {u'count': 163, u'_id': u'place_of_worship'}
    {u'count': 142, u'_id': u'telephone'}
    {u'count': 130, u'_id': u'restaurant'}
    {u'count': 110, u'_id': u'cafe'}
    {u'count': 102, u'_id': u'school'}
```

### The top 10 most common types of cuisine

For food nodes where the cuisine is known.

```python
>>> collection.aggregate([
        {"$match": {"cuisine": {"$exists": 1}}},
        {"$group": {"_id": "$cuisine", "count": {"$sum": 1}}},
        {"$sort": {"count": -1}},
        {"$limit": 10}
    ])


>>> {u'count': 31, u'_id': u'chinese'}
    {u'count': 26, u'_id': u'sandwich'}
    {u'count': 20, u'_id': u'indian'}
    {u'count': 15, u'_id': u'coffee_shop'}
    {u'count': 11, u'_id': u'fish_and_chips'}
    {u'count': 11, u'_id': u'burger'}
    {u'count': 11, u'_id': u'pizza'}
    {u'count': 10, u'_id': u'italian'}
    {u'count': 6, u'_id': u'thai'}
    {u'count': 5, u'_id': u'asian'}
```

### Top 10 most commonly found places to eat

```python
>>> collection.aggregate([
        {"$match": {"amenity": {"$in": ["restaurant", "cafe", "pub", "bar", "fast_food", "delicatessen"]}}},
        {"$match": {"name": {"$exists": 1}}},
        {"$group": {
                "_id": "$name",
                "amenity": {"$first": "$amenity"},
                "cuisine": {"$push": "$cuisine"},
                "count": {"$sum": 1}
            }},
        {"$project": {
                "_id": 0,
                "count": 1,
                "name": "$_id",
                "type" : {"$concat": [
                        "$amenity", " - ",
                        {"$ifNull": [{"$arrayElemAt": ["$cuisine", 0 ]}, "unknown cuisine"] }
                    ]}
            }},
        {"$sort": {"count": -1}},
        {"$limit": 10}
    ])

>>> Count 6: The Red Lion (pub - unknown cuisine)
    Count 5: La Croissanterie (cafe - unknown cuisine)
    Count 5: Taylors (restaurant - sandwich)
    Count 4: The White Hart (pub - unknown cuisine)
    Count 3: Mission Burrito (fast_food - mexican)
    Count 3: McDonald's (fast_food - burger)
    Count 3: Subway (fast_food - sandwich)
    Count 3: Pizza Hut (restaurant - pizza)
    Count 3: Mortons (cafe - sandwich)
    Count 3: Costa Coffee (cafe - unknown cuisine)
```

It is interesting to note that Asian cuisines occupy 4 of the top top types of cuisine (1: Chinese, 3: Indian, 9: Thai, 1: Asian), yet there isn't a single business offering Asian cuisine in the top 10 most commonly found places to eat. This begins to illustrate the trend that even though business offering Asian cuisine are numerous, they tend to be independent establishments rather than franchises or chains.

### The total reported bicycle parking capacity

We can't make any assumptions for records where 'capacity' is known.

```python
>>> collection.inline_map_reduce(
        Code("function() {"
             "    if (this.capacity) {"
             "        emit('total_bicycle_parking_capacity', Number(this.capacity));"
             "    }"
             "}"),
        Code("function(key, values) {"
             "    var total = 0;"
             "    for (var i = 0; i < values.length; i++) {"
             "        total += values[i];"
             "    }"
             "    return total;"
             "}"),
        query = {"amenity": "bicycle_parking"});

>>> {u'_id': u'total_bicycle_parking_capacity', u'value': 8756.0}]
```

### The 5 streets with the most bus stops

For bus stop nodes where the street name is known.


```python
>>> collection.aggregate([
        {"$match": {"naptan": {"$exists": 1}, "highway": "bus_stop"}},
        {"$group": {"_id": "$naptan.Street", "num_bus_stops": {"$sum": 1}}},
        {"$project": {"_id": 0, "num_bus_stops": 1, "street_name": "$_id"}},
        {"$sort": {"num_bus_stops": -1}},
        {"$limit": 5}
    ])

>>> {u'street_name': u'Oxford Road', u'num_bus_stops': 43}
    {u'street_name': u'Banbury Road', u'num_bus_stops': 40}
    {u'street_name': u'Woodstock Road', u'num_bus_stops': 33}
    {u'street_name': u'High Street', u'num_bus_stops': 23}
    {u'street_name': u'Cowley Road', u'num_bus_stops': 20}
```

## Conclusion

I am pleasantly surprised to see just how much information about Oxford is encoded within the OSM data. That said, the inevitable nature of crowd sourced information is clearly present. There is quite a lot of inconsistency in the data (not all illustrated in this project) as well as records that do little more than act as meta information about the creation of the data itself (such as 'fixme' and 'note'). There are 78 'meta' tag key names that include 'fixme' or 'note' making up 7.72% of all unique tag key names.

The first 5 of these tag names are: 'note2', 'Fixme:responce_2', 'frequency:note', 'note:17', 'note:14'...

### Resources

The production of this project was aided by information found on the following website (various authors and contributors)

- [Udacity.com](udacity.com)
- [Docs.MongoDB.com](docs.mongodb.com)
- [API.MongoDB.com/python](api.mongodb.com/python)
- [StackOverflow.com](stackoverflow.com)
